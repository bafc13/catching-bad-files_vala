/* md5-compare.c generated by valac 0.56.17, the Vala compiler
 * generated from md5-compare.vala, do not modify */

#include "md5-compare.h"
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib/gstdio.h>
#include <gio/gio.h>
#include <stdio.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif

enum  {
	FILE_INTEGRITY_CHECKER_FILE_COMPARATOR_0_PROPERTY,
	FILE_INTEGRITY_CHECKER_FILE_COMPARATOR_NUM_PROPERTIES
};
static GParamSpec* file_integrity_checker_file_comparator_properties[FILE_INTEGRITY_CHECKER_FILE_COMPARATOR_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
enum  {
	FILE_INTEGRITY_CHECKER_FILE_UTILS_0_PROPERTY,
	FILE_INTEGRITY_CHECKER_FILE_UTILS_NUM_PROPERTIES
};
static GParamSpec* file_integrity_checker_file_utils_properties[FILE_INTEGRITY_CHECKER_FILE_UTILS_NUM_PROPERTIES];
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _g_checksum_free0(var) ((var == NULL) ? NULL : (var = (g_checksum_free (var), NULL)))

static gpointer file_integrity_checker_file_comparator_parent_class = NULL;
static gpointer file_integrity_checker_file_utils_parent_class = NULL;

static void _g_free0_ (gpointer var);
static inline void _g_list_free__g_free0_ (GList* self);
static void file_integrity_checker_file_comparator_finalize (GObject * obj);
static GType file_integrity_checker_file_comparator_get_type_once (void);
static GType file_integrity_checker_file_utils_get_type_once (void);

static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}

static inline void
_g_list_free__g_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_free0_);
}

FileIntegrityCheckerFileComparator*
file_integrity_checker_file_comparator_construct (GType object_type,
                                                  const gchar* dir1,
                                                  const gchar* dir2)
{
	FileIntegrityCheckerFileComparator * self = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (dir1 != NULL, NULL);
	g_return_val_if_fail (dir2 != NULL, NULL);
	self = (FileIntegrityCheckerFileComparator*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup (dir1);
	_g_free0 (self->directory1);
	self->directory1 = _tmp0_;
	_tmp1_ = g_strdup (dir2);
	_g_free0 (self->directory2);
	self->directory2 = _tmp1_;
	return self;
}

FileIntegrityCheckerFileComparator*
file_integrity_checker_file_comparator_new (const gchar* dir1,
                                            const gchar* dir2)
{
	return file_integrity_checker_file_comparator_construct (FILE_INTEGRITY_CHECKER_TYPE_FILE_COMPARATOR, dir1, dir2);
}

void
file_integrity_checker_file_comparator_compare_directories (FileIntegrityCheckerFileComparator* self)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GDir* opened_directory1 = NULL;
		const gchar* _tmp0_;
		GDir* _tmp1_;
		GDir* opened_directory2 = NULL;
		const gchar* _tmp2_;
		GDir* _tmp3_;
		gboolean _tmp4_ = FALSE;
		GDir* _tmp5_;
		gint index = 0;
		GList* _tmp9_;
		_tmp0_ = self->directory1;
		_tmp1_ = g_dir_open (_tmp0_, (guint) 0, &_inner_error0_);
		opened_directory1 = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp2_ = self->directory2;
		_tmp3_ = g_dir_open (_tmp2_, (guint) 0, &_inner_error0_);
		opened_directory2 = _tmp3_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_dir_close0 (opened_directory1);
			goto __catch0_g_error;
		}
		_tmp5_ = opened_directory1;
		if (_tmp5_ != NULL) {
			GDir* _tmp6_;
			_tmp6_ = opened_directory2;
			_tmp4_ = _tmp6_ != NULL;
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			const gchar* _tmp7_;
			const gchar* _tmp8_;
			_tmp7_ = self->directory1;
			file_integrity_checker_file_comparator_traverse_directory (self, _tmp7_, 0);
			_tmp8_ = self->directory2;
			file_integrity_checker_file_comparator_traverse_directory (self, _tmp8_, 1);
		}
		index = 0;
		_tmp9_ = self->dir1_files_list;
		{
			GList* file_collection = NULL;
			GList* file_it = NULL;
			file_collection = _tmp9_;
			for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
				gchar* _tmp10_;
				gchar* file = NULL;
				_tmp10_ = g_strdup ((const gchar*) file_it->data);
				file = _tmp10_;
				{
					GList* _tmp11_;
					gint _tmp15_;
					_tmp11_ = self->dir2_files_list;
					if (((guint) index) < g_list_length (_tmp11_)) {
						gboolean ok = FALSE;
						const gchar* _tmp12_;
						GList* _tmp13_;
						gconstpointer _tmp14_;
						_tmp12_ = file;
						_tmp13_ = self->dir2_files_list;
						_tmp14_ = g_list_nth_data (_tmp13_, (guint) index);
						ok = file_integrity_checker_file_comparator_check_file_integrity (self, _tmp12_, (const gchar*) _tmp14_);
						self->dir_compare_int_result = g_list_append (self->dir_compare_int_result, (gpointer) ((gintptr) ok));
					}
					_tmp15_ = index;
					index = _tmp15_ + 1;
					_g_free0 (file);
				}
			}
		}
		_g_dir_close0 (opened_directory2);
		_g_dir_close0 (opened_directory1);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp16_;
		const gchar* _tmp17_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp16_ = e;
		_tmp17_ = _tmp16_->message;
		g_print ("Error: %s\n", _tmp17_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	file_integrity_checker_file_comparator_generate_report (self);
}

void
file_integrity_checker_file_comparator_traverse_directory (FileIntegrityCheckerFileComparator* self,
                                                           const gchar* path,
                                                           gint num)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	{
		GDir* dir = NULL;
		GDir* _tmp0_;
		gchar* entry = NULL;
		_tmp0_ = g_dir_open (path, (guint) 0, &_inner_error0_);
		dir = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		while (TRUE) {
			GDir* _tmp1_;
			const gchar* _tmp2_;
			gchar* _tmp3_;
			const gchar* _tmp4_;
			gboolean _tmp5_ = FALSE;
			const gchar* _tmp6_;
			gchar* full_path = NULL;
			gchar* _tmp8_;
			gchar* _tmp9_;
			const gchar* _tmp10_;
			gchar* _tmp11_;
			gchar* _tmp12_;
			const gchar* _tmp17_;
			_tmp1_ = dir;
			_tmp2_ = g_dir_read_name (_tmp1_);
			_tmp3_ = g_strdup (_tmp2_);
			_g_free0 (entry);
			entry = _tmp3_;
			_tmp4_ = entry;
			if (!(_tmp4_ != NULL)) {
				break;
			}
			_tmp6_ = entry;
			if (g_strcmp0 (_tmp6_, ".") == 0) {
				_tmp5_ = TRUE;
			} else {
				const gchar* _tmp7_;
				_tmp7_ = entry;
				_tmp5_ = g_strcmp0 (_tmp7_, "..") == 0;
			}
			if (_tmp5_) {
				continue;
			}
			_tmp8_ = g_strconcat (path, "/", NULL);
			_tmp9_ = _tmp8_;
			_tmp10_ = entry;
			_tmp11_ = g_strconcat (_tmp9_, _tmp10_, NULL);
			_tmp12_ = _tmp11_;
			_g_free0 (_tmp9_);
			full_path = _tmp12_;
			if (num == 0) {
				const gchar* _tmp13_;
				gchar* _tmp14_;
				_tmp13_ = full_path;
				_tmp14_ = g_strdup (_tmp13_);
				self->dir1_files_list = g_list_append (self->dir1_files_list, _tmp14_);
			}
			if (num == 1) {
				const gchar* _tmp15_;
				gchar* _tmp16_;
				_tmp15_ = full_path;
				_tmp16_ = g_strdup (_tmp15_);
				self->dir2_files_list = g_list_append (self->dir2_files_list, _tmp16_);
			}
			_tmp17_ = full_path;
			if (g_file_test (_tmp17_, G_FILE_TEST_IS_DIR)) {
				const gchar* _tmp18_;
				_tmp18_ = full_path;
				file_integrity_checker_file_comparator_traverse_directory (self, _tmp18_, num);
			}
			_g_free0 (full_path);
		}
		_g_free0 (entry);
		_g_dir_close0 (dir);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp19_;
		const gchar* _tmp20_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp19_ = e;
		_tmp20_ = _tmp19_->message;
		g_print ("Error while traversing directory %s: %s\n", path, _tmp20_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

gboolean
file_integrity_checker_file_comparator_check_file_integrity (FileIntegrityCheckerFileComparator* self,
                                                             const gchar* file1,
                                                             const gchar* file2)
{
	gchar* sum1 = NULL;
	gchar* _tmp0_;
	gchar* sum2 = NULL;
	gchar* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file1 != NULL, FALSE);
	g_return_val_if_fail (file2 != NULL, FALSE);
	_tmp0_ = file_integrity_checker_file_utils_calculate_checksum (file1);
	sum1 = _tmp0_;
	_tmp1_ = file_integrity_checker_file_utils_calculate_checksum (file2);
	sum2 = _tmp1_;
	result = g_strcmp0 (sum1, sum2) == 0;
	_g_free0 (sum2);
	_g_free0 (sum1);
	return result;
}

void
file_integrity_checker_file_comparator_generate_report (FileIntegrityCheckerFileComparator* self)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_;
		gsize bwritten = 0UL;
		GFileOutputStream* log_stream = NULL;
		GFile* _tmp1_;
		GFileOutputStream* _tmp2_;
		GFileOutputStream* _tmp3_;
		_tmp0_ = g_file_new_for_path ("log.txt");
		file = _tmp0_;
		bwritten = (gsize) 0;
		_tmp1_ = file;
		_tmp2_ = g_file_replace (_tmp1_, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &_inner_error0_);
		log_stream = _tmp2_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (file);
			goto __catch0_g_error;
		}
		_tmp3_ = log_stream;
		if (_tmp3_ != NULL) {
			gint index = 0;
			GFileOutputStream* _tmp4_;
			gsize _tmp5_ = 0UL;
			GList* _tmp6_;
			GFileOutputStream* _tmp12_;
			index = 0;
			_tmp4_ = log_stream;
			g_output_stream_printf ((GOutputStream*) _tmp4_, &_tmp5_, NULL, &_inner_error0_, "Legend: 1 - success copy, 0 - failed copy(error)");
			bwritten = _tmp5_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (log_stream);
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
			_tmp6_ = self->dir_compare_int_result;
			{
				GList* item_collection = NULL;
				GList* item_it = NULL;
				item_collection = _tmp6_;
				for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
					gint item = 0;
					item = (gint) ((gintptr) item_it->data);
					{
						GFileOutputStream* _tmp7_;
						GList* _tmp8_;
						gconstpointer _tmp9_;
						gsize _tmp10_ = 0UL;
						gint _tmp11_;
						_tmp7_ = log_stream;
						_tmp8_ = self->dir1_files_list;
						_tmp9_ = g_list_nth_data (_tmp8_, (guint) index);
						g_output_stream_printf ((GOutputStream*) _tmp7_, &_tmp10_, NULL, &_inner_error0_, "%d  -  %s\n", item, (const gchar*) _tmp9_);
						bwritten = _tmp10_;
						if (G_UNLIKELY (_inner_error0_ != NULL)) {
							_g_object_unref0 (log_stream);
							_g_object_unref0 (file);
							goto __catch0_g_error;
						}
						_tmp11_ = index;
						index = _tmp11_ + 1;
					}
				}
			}
			_tmp12_ = log_stream;
			g_output_stream_close ((GOutputStream*) _tmp12_, NULL, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (log_stream);
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
		} else {
			g_print ("Error while generating log, can't open log.txt\n");
		}
		_g_object_unref0 (log_stream);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp13_;
		const gchar* _tmp14_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp13_ = e;
		_tmp14_ = _tmp13_->message;
		g_print ("Error while generating log: %s\n", _tmp14_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
file_integrity_checker_file_comparator_class_init (FileIntegrityCheckerFileComparatorClass * klass,
                                                   gpointer klass_data)
{
	file_integrity_checker_file_comparator_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = file_integrity_checker_file_comparator_finalize;
}

static void
file_integrity_checker_file_comparator_instance_init (FileIntegrityCheckerFileComparator * self,
                                                      gpointer klass)
{
	self->dir1_files_list = NULL;
	self->dir2_files_list = NULL;
	self->dir_compare_int_result = NULL;
}

static void
file_integrity_checker_file_comparator_finalize (GObject * obj)
{
	FileIntegrityCheckerFileComparator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILE_INTEGRITY_CHECKER_TYPE_FILE_COMPARATOR, FileIntegrityCheckerFileComparator);
	_g_free0 (self->directory1);
	_g_free0 (self->directory2);
	(self->dir1_files_list == NULL) ? NULL : (self->dir1_files_list = (_g_list_free__g_free0_ (self->dir1_files_list), NULL));
	(self->dir2_files_list == NULL) ? NULL : (self->dir2_files_list = (_g_list_free__g_free0_ (self->dir2_files_list), NULL));
	(self->dir_compare_int_result == NULL) ? NULL : (self->dir_compare_int_result = (g_list_free (self->dir_compare_int_result), NULL));
	G_OBJECT_CLASS (file_integrity_checker_file_comparator_parent_class)->finalize (obj);
}

static GType
file_integrity_checker_file_comparator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FileIntegrityCheckerFileComparatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) file_integrity_checker_file_comparator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FileIntegrityCheckerFileComparator), 0, (GInstanceInitFunc) file_integrity_checker_file_comparator_instance_init, NULL };
	GType file_integrity_checker_file_comparator_type_id;
	file_integrity_checker_file_comparator_type_id = g_type_register_static (G_TYPE_OBJECT, "FileIntegrityCheckerFileComparator", &g_define_type_info, 0);
	return file_integrity_checker_file_comparator_type_id;
}

GType
file_integrity_checker_file_comparator_get_type (void)
{
	static volatile gsize file_integrity_checker_file_comparator_type_id__once = 0;
	if (g_once_init_enter (&file_integrity_checker_file_comparator_type_id__once)) {
		GType file_integrity_checker_file_comparator_type_id;
		file_integrity_checker_file_comparator_type_id = file_integrity_checker_file_comparator_get_type_once ();
		g_once_init_leave (&file_integrity_checker_file_comparator_type_id__once, file_integrity_checker_file_comparator_type_id);
	}
	return file_integrity_checker_file_comparator_type_id__once;
}

gchar*
file_integrity_checker_file_utils_calculate_checksum (const gchar* file_path)
{
	GChecksum* checksum = NULL;
	GChecksum* _tmp0_;
	gchar* md5_sum = NULL;
	GChecksum* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	GError* _inner_error0_ = NULL;
	gchar* result;
	g_return_val_if_fail (file_path != NULL, NULL);
	_tmp0_ = g_checksum_new (G_CHECKSUM_MD5);
	checksum = _tmp0_;
	{
		FILE* stream = NULL;
		FILE* _tmp1_;
		FILE* _tmp2_;
		_tmp1_ = g_fopen (file_path, "rb");
		stream = _tmp1_;
		_tmp2_ = stream;
		if (_tmp2_ != NULL) {
			guint8* buffer = NULL;
			guint8* _tmp3_;
			gint buffer_length1;
			gint _buffer_size_;
			gsize bytes_read = 0UL;
			_tmp3_ = g_new0 (guint8, 4096);
			buffer = _tmp3_;
			buffer_length1 = 4096;
			_buffer_size_ = buffer_length1;
			while (TRUE) {
				FILE* _tmp4_;
				guint8* _tmp5_;
				gint _tmp5__length1;
				GChecksum* _tmp6_;
				guint8* _tmp7_;
				gint _tmp7__length1;
				_tmp4_ = stream;
				_tmp5_ = buffer;
				_tmp5__length1 = buffer_length1;
				bytes_read = fread (_tmp5_, (gsize) 1, (gint) _tmp5__length1, _tmp4_);
				if (!(bytes_read > ((gsize) 0))) {
					break;
				}
				_tmp6_ = checksum;
				_tmp7_ = buffer;
				_tmp7__length1 = buffer_length1;
				g_checksum_update (_tmp6_, _tmp7_, (gsize) bytes_read);
			}
			buffer = (g_free (buffer), NULL);
		}
		_fclose0 (stream);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp8_;
		const gchar* _tmp9_;
		gchar* _tmp10_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		g_print ("Error while calculating checksum: %s\n", _tmp9_);
		_tmp10_ = g_strdup ("Error");
		result = _tmp10_;
		_g_error_free0 (e);
		_g_free0 (md5_sum);
		_g_checksum_free0 (checksum);
		return result;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (md5_sum);
		_g_checksum_free0 (checksum);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	_tmp11_ = checksum;
	_tmp12_ = g_checksum_get_string (_tmp11_);
	_tmp13_ = g_strdup (_tmp12_);
	_g_free0 (md5_sum);
	md5_sum = _tmp13_;
	result = md5_sum;
	_g_checksum_free0 (checksum);
	return result;
}

gboolean
file_integrity_checker_file_utils_compare_files_by_bytes (const gchar* file1,
                                                          const gchar* file2)
{
	gboolean _tmp16_ = FALSE;
	GError* _inner_error0_ = NULL;
	gboolean result;
	g_return_val_if_fail (file1 != NULL, FALSE);
	g_return_val_if_fail (file2 != NULL, FALSE);
	{
		FILE* stream1 = NULL;
		FILE* _tmp0_;
		FILE* stream2 = NULL;
		FILE* _tmp1_;
		guint8* buffer1 = NULL;
		guint8* _tmp2_;
		gint buffer1_length1;
		gint _buffer1_size_;
		guint8* buffer2 = NULL;
		guint8* _tmp3_;
		gint buffer2_length1;
		gint _buffer2_size_;
		gsize bytes_read1 = 0UL;
		gsize bytes_read2 = 0UL;
		gboolean are_equal = FALSE;
		_tmp0_ = g_fopen (file1, "rb");
		stream1 = _tmp0_;
		_tmp1_ = g_fopen (file2, "rb");
		stream2 = _tmp1_;
		_tmp2_ = g_new0 (guint8, 4096);
		buffer1 = _tmp2_;
		buffer1_length1 = 4096;
		_buffer1_size_ = buffer1_length1;
		_tmp3_ = g_new0 (guint8, 4096);
		buffer2 = _tmp3_;
		buffer2_length1 = 4096;
		_buffer2_size_ = buffer2_length1;
		are_equal = TRUE;
		while (TRUE) {
			FILE* _tmp4_;
			guint8* _tmp5_;
			gint _tmp5__length1;
			FILE* _tmp6_;
			guint8* _tmp7_;
			gint _tmp7__length1;
			_tmp4_ = stream1;
			_tmp5_ = buffer1;
			_tmp5__length1 = buffer1_length1;
			bytes_read1 = fread (_tmp5_, (gsize) 1, (gint) _tmp5__length1, _tmp4_);
			_tmp6_ = stream2;
			_tmp7_ = buffer2;
			_tmp7__length1 = buffer2_length1;
			bytes_read2 = fread (_tmp7_, (gsize) 1, (gint) _tmp7__length1, _tmp6_);
			if (bytes_read1 != bytes_read2) {
				are_equal = FALSE;
				break;
			}
			if (bytes_read1 == ((gsize) 0)) {
				break;
			}
			{
				gsize i = 0UL;
				i = (gsize) 0;
				{
					gboolean _tmp8_ = FALSE;
					_tmp8_ = TRUE;
					while (TRUE) {
						guint8* _tmp10_;
						gint _tmp10__length1;
						guint8 _tmp11_;
						guint8* _tmp12_;
						gint _tmp12__length1;
						guint8 _tmp13_;
						if (!_tmp8_) {
							gsize _tmp9_;
							_tmp9_ = i;
							i = _tmp9_ + 1;
						}
						_tmp8_ = FALSE;
						if (!(i < bytes_read1)) {
							break;
						}
						_tmp10_ = buffer1;
						_tmp10__length1 = buffer1_length1;
						_tmp11_ = _tmp10_[i];
						_tmp12_ = buffer2;
						_tmp12__length1 = buffer2_length1;
						_tmp13_ = _tmp12_[i];
						if (_tmp11_ != _tmp13_) {
							are_equal = FALSE;
							break;
						}
					}
				}
			}
			if (!are_equal) {
				break;
			}
		}
		if (are_equal) {
			result = TRUE;
			buffer2 = (g_free (buffer2), NULL);
			buffer1 = (g_free (buffer1), NULL);
			_fclose0 (stream2);
			_fclose0 (stream1);
			return result;
		} else {
			result = FALSE;
			buffer2 = (g_free (buffer2), NULL);
			buffer1 = (g_free (buffer1), NULL);
			_fclose0 (stream2);
			_fclose0 (stream1);
			return result;
		}
		buffer2 = (g_free (buffer2), NULL);
		buffer1 = (g_free (buffer1), NULL);
		_fclose0 (stream2);
		_fclose0 (stream1);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp14_;
		const gchar* _tmp15_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp14_ = e;
		_tmp15_ = _tmp14_->message;
		g_print ("Error: %s\n", _tmp15_);
		_g_error_free0 (e);
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return _tmp16_;
}

FileIntegrityCheckerFileUtils*
file_integrity_checker_file_utils_construct (GType object_type)
{
	FileIntegrityCheckerFileUtils * self = NULL;
	self = (FileIntegrityCheckerFileUtils*) g_object_new (object_type, NULL);
	return self;
}

FileIntegrityCheckerFileUtils*
file_integrity_checker_file_utils_new (void)
{
	return file_integrity_checker_file_utils_construct (FILE_INTEGRITY_CHECKER_TYPE_FILE_UTILS);
}

static void
file_integrity_checker_file_utils_class_init (FileIntegrityCheckerFileUtilsClass * klass,
                                              gpointer klass_data)
{
	file_integrity_checker_file_utils_parent_class = g_type_class_peek_parent (klass);
}

static void
file_integrity_checker_file_utils_instance_init (FileIntegrityCheckerFileUtils * self,
                                                 gpointer klass)
{
}

static GType
file_integrity_checker_file_utils_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FileIntegrityCheckerFileUtilsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) file_integrity_checker_file_utils_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FileIntegrityCheckerFileUtils), 0, (GInstanceInitFunc) file_integrity_checker_file_utils_instance_init, NULL };
	GType file_integrity_checker_file_utils_type_id;
	file_integrity_checker_file_utils_type_id = g_type_register_static (G_TYPE_OBJECT, "FileIntegrityCheckerFileUtils", &g_define_type_info, 0);
	return file_integrity_checker_file_utils_type_id;
}

GType
file_integrity_checker_file_utils_get_type (void)
{
	static volatile gsize file_integrity_checker_file_utils_type_id__once = 0;
	if (g_once_init_enter (&file_integrity_checker_file_utils_type_id__once)) {
		GType file_integrity_checker_file_utils_type_id;
		file_integrity_checker_file_utils_type_id = file_integrity_checker_file_utils_get_type_once ();
		g_once_init_leave (&file_integrity_checker_file_utils_type_id__once, file_integrity_checker_file_utils_type_id);
	}
	return file_integrity_checker_file_utils_type_id__once;
}


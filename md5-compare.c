/* md5-compare.c generated by valac 0.56.17, the Vala compiler
 * generated from md5-compare.vala, do not modify */

#include "md5-compare.h"
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib/gstdio.h>
#include <gio/gio.h>
#include <stdio.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif

enum  {
	FILE_INTEGRITY_CHECKER_FILE_COMPARATOR_0_PROPERTY,
	FILE_INTEGRITY_CHECKER_FILE_COMPARATOR_NUM_PROPERTIES
};
static GParamSpec* file_integrity_checker_file_comparator_properties[FILE_INTEGRITY_CHECKER_FILE_COMPARATOR_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_dir_close0(var) ((var == NULL) ? NULL : (var = (g_dir_close (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
enum  {
	FILE_INTEGRITY_CHECKER_FILE_UTILS_0_PROPERTY,
	FILE_INTEGRITY_CHECKER_FILE_UTILS_NUM_PROPERTIES
};
static GParamSpec* file_integrity_checker_file_utils_properties[FILE_INTEGRITY_CHECKER_FILE_UTILS_NUM_PROPERTIES];
#define _fclose0(var) ((var == NULL) ? NULL : (var = (fclose (var), NULL)))
#define _g_checksum_free0(var) ((var == NULL) ? NULL : (var = (g_checksum_free (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))

static gpointer file_integrity_checker_file_comparator_parent_class = NULL;
static gpointer file_integrity_checker_file_utils_parent_class = NULL;

static void _g_free0_ (gpointer var);
static inline void _g_list_free__g_free0_ (GList* self);
static void file_integrity_checker_file_comparator_finalize (GObject * obj);
static GType file_integrity_checker_file_comparator_get_type_once (void);
static void file_integrity_checker_file_utils_finalize (GObject * obj);
static GType file_integrity_checker_file_utils_get_type_once (void);

static void
_g_free0_ (gpointer var)
{
	var = (g_free (var), NULL);
}

static inline void
_g_list_free__g_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_free0_);
}

FileIntegrityCheckerFileComparator*
file_integrity_checker_file_comparator_construct (GType object_type,
                                                  const gchar* dir1,
                                                  const gchar* dir2)
{
	FileIntegrityCheckerFileComparator * self = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (dir1 != NULL, NULL);
	g_return_val_if_fail (dir2 != NULL, NULL);
	self = (FileIntegrityCheckerFileComparator*) g_object_new (object_type, NULL);
	_tmp0_ = g_strdup (dir1);
	_g_free0 (self->directory1);
	self->directory1 = _tmp0_;
	_tmp1_ = g_strdup (dir2);
	_g_free0 (self->directory2);
	self->directory2 = _tmp1_;
	return self;
}

FileIntegrityCheckerFileComparator*
file_integrity_checker_file_comparator_new (const gchar* dir1,
                                            const gchar* dir2)
{
	return file_integrity_checker_file_comparator_construct (FILE_INTEGRITY_CHECKER_TYPE_FILE_COMPARATOR, dir1, dir2);
}

void
file_integrity_checker_file_comparator_compare_directories (FileIntegrityCheckerFileComparator* self)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GDir* opened_directory1 = NULL;
		const gchar* _tmp0_;
		GDir* _tmp1_;
		GDir* opened_directory2 = NULL;
		const gchar* _tmp2_;
		GDir* _tmp3_;
		gboolean _tmp4_ = FALSE;
		GDir* _tmp5_;
		gint index = 0;
		GList* _tmp9_;
		_tmp0_ = self->directory1;
		_tmp1_ = g_dir_open (_tmp0_, (guint) 0, &_inner_error0_);
		opened_directory1 = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		_tmp2_ = self->directory2;
		_tmp3_ = g_dir_open (_tmp2_, (guint) 0, &_inner_error0_);
		opened_directory2 = _tmp3_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_dir_close0 (opened_directory1);
			goto __catch0_g_error;
		}
		_tmp5_ = opened_directory1;
		if (_tmp5_ != NULL) {
			GDir* _tmp6_;
			_tmp6_ = opened_directory2;
			_tmp4_ = _tmp6_ != NULL;
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			const gchar* _tmp7_;
			const gchar* _tmp8_;
			_tmp7_ = self->directory1;
			file_integrity_checker_file_comparator_traverse_directory (self, _tmp7_, 0);
			_tmp8_ = self->directory2;
			file_integrity_checker_file_comparator_traverse_directory (self, _tmp8_, 1);
		}
		index = 0;
		_tmp9_ = self->dir1_files_list;
		{
			GList* file_collection = NULL;
			GList* file_it = NULL;
			file_collection = _tmp9_;
			for (file_it = file_collection; file_it != NULL; file_it = file_it->next) {
				gchar* _tmp10_;
				gchar* file = NULL;
				_tmp10_ = g_strdup ((const gchar*) file_it->data);
				file = _tmp10_;
				{
					GList* _tmp11_;
					gint _tmp15_;
					_tmp11_ = self->dir2_files_list;
					if (((guint) index) < g_list_length (_tmp11_)) {
						gboolean ok = FALSE;
						const gchar* _tmp12_;
						GList* _tmp13_;
						gconstpointer _tmp14_;
						_tmp12_ = file;
						_tmp13_ = self->dir2_files_list;
						_tmp14_ = g_list_nth_data (_tmp13_, (guint) index);
						ok = file_integrity_checker_file_comparator_check_file_integrity (self, _tmp12_, (const gchar*) _tmp14_);
						self->dir_compare_int_result = g_list_append (self->dir_compare_int_result, (gpointer) ((gintptr) ok));
					}
					_tmp15_ = index;
					index = _tmp15_ + 1;
					_g_free0 (file);
				}
			}
		}
		_g_dir_close0 (opened_directory2);
		_g_dir_close0 (opened_directory1);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp16_;
		const gchar* _tmp17_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp16_ = e;
		_tmp17_ = _tmp16_->message;
		g_print ("Error: %s\n", _tmp17_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
	file_integrity_checker_file_comparator_generate_report (self);
}

void
file_integrity_checker_file_comparator_traverse_directory (FileIntegrityCheckerFileComparator* self,
                                                           const gchar* path,
                                                           gint num)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (path != NULL);
	{
		GDir* dir = NULL;
		GDir* _tmp0_;
		gchar* entry = NULL;
		_tmp0_ = g_dir_open (path, (guint) 0, &_inner_error0_);
		dir = _tmp0_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			goto __catch0_g_error;
		}
		while (TRUE) {
			GDir* _tmp1_;
			const gchar* _tmp2_;
			gchar* _tmp3_;
			const gchar* _tmp4_;
			gboolean _tmp5_ = FALSE;
			const gchar* _tmp6_;
			gchar* full_path = NULL;
			gchar* _tmp8_;
			gchar* _tmp9_;
			const gchar* _tmp10_;
			gchar* _tmp11_;
			gchar* _tmp12_;
			const gchar* _tmp17_;
			_tmp1_ = dir;
			_tmp2_ = g_dir_read_name (_tmp1_);
			_tmp3_ = g_strdup (_tmp2_);
			_g_free0 (entry);
			entry = _tmp3_;
			_tmp4_ = entry;
			if (!(_tmp4_ != NULL)) {
				break;
			}
			_tmp6_ = entry;
			if (g_strcmp0 (_tmp6_, ".") == 0) {
				_tmp5_ = TRUE;
			} else {
				const gchar* _tmp7_;
				_tmp7_ = entry;
				_tmp5_ = g_strcmp0 (_tmp7_, "..") == 0;
			}
			if (_tmp5_) {
				continue;
			}
			_tmp8_ = g_strconcat (path, "/", NULL);
			_tmp9_ = _tmp8_;
			_tmp10_ = entry;
			_tmp11_ = g_strconcat (_tmp9_, _tmp10_, NULL);
			_tmp12_ = _tmp11_;
			_g_free0 (_tmp9_);
			full_path = _tmp12_;
			if (num == 0) {
				const gchar* _tmp13_;
				gchar* _tmp14_;
				_tmp13_ = full_path;
				_tmp14_ = g_strdup (_tmp13_);
				self->dir1_files_list = g_list_append (self->dir1_files_list, _tmp14_);
			}
			if (num == 1) {
				const gchar* _tmp15_;
				gchar* _tmp16_;
				_tmp15_ = full_path;
				_tmp16_ = g_strdup (_tmp15_);
				self->dir2_files_list = g_list_append (self->dir2_files_list, _tmp16_);
			}
			_tmp17_ = full_path;
			if (g_file_test (_tmp17_, G_FILE_TEST_IS_DIR)) {
				const gchar* _tmp18_;
				_tmp18_ = full_path;
				file_integrity_checker_file_comparator_traverse_directory (self, _tmp18_, num);
			}
			_g_free0 (full_path);
		}
		_g_free0 (entry);
		_g_dir_close0 (dir);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp19_;
		const gchar* _tmp20_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp19_ = e;
		_tmp20_ = _tmp19_->message;
		g_print ("Error while traversing directory %s: %s\n", path, _tmp20_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

gboolean
file_integrity_checker_file_comparator_check_file_integrity (FileIntegrityCheckerFileComparator* self,
                                                             const gchar* file1,
                                                             const gchar* file2)
{
	gchar* sum1 = NULL;
	gchar* _tmp0_;
	gchar* sum2 = NULL;
	gchar* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (file1 != NULL, FALSE);
	g_return_val_if_fail (file2 != NULL, FALSE);
	_tmp0_ = file_integrity_checker_file_utils_calculate_checksum (file1);
	sum1 = _tmp0_;
	_tmp1_ = file_integrity_checker_file_utils_calculate_checksum (file2);
	sum2 = _tmp1_;
	result = g_strcmp0 (sum1, sum2) == 0;
	_g_free0 (sum2);
	_g_free0 (sum1);
	return result;
}

void
file_integrity_checker_file_comparator_generate_report (FileIntegrityCheckerFileComparator* self)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_;
		gsize bwritten = 0UL;
		GFileOutputStream* log_stream = NULL;
		GFile* _tmp1_;
		GFileOutputStream* _tmp2_;
		GFileOutputStream* _tmp3_;
		_tmp0_ = g_file_new_for_path ("log");
		file = _tmp0_;
		bwritten = (gsize) 0;
		_tmp1_ = file;
		_tmp2_ = g_file_replace (_tmp1_, NULL, FALSE, G_FILE_CREATE_NONE, NULL, &_inner_error0_);
		log_stream = _tmp2_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (file);
			goto __catch0_g_error;
		}
		_tmp3_ = log_stream;
		if (_tmp3_ != NULL) {
			gint join_0_count = 0;
			GList* _tmp4_;
			gint index = 0;
			GFileOutputStream* _tmp6_;
			gsize _tmp7_ = 0UL;
			GFileOutputStream* _tmp8_;
			gsize _tmp9_ = 0UL;
			GFileOutputStream* _tmp10_;
			GList* _tmp11_;
			gsize _tmp12_ = 0UL;
			GList* _tmp13_;
			GFileOutputStream* _tmp19_;
			join_0_count = 0;
			_tmp4_ = self->dir_compare_int_result;
			{
				GList* item_collection = NULL;
				GList* item_it = NULL;
				item_collection = _tmp4_;
				for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
					gint item = 0;
					item = (gint) ((gintptr) item_it->data);
					{
						if (item == 0) {
							gint _tmp5_;
							_tmp5_ = join_0_count;
							join_0_count = _tmp5_ + 1;
						}
					}
				}
			}
			index = 0;
			_tmp6_ = log_stream;
			g_output_stream_printf ((GOutputStream*) _tmp6_, &_tmp7_, NULL, &_inner_error0_, "Legend: 1 - success copy, 0 - failed copy(error)\n");
			bwritten = _tmp7_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (log_stream);
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
			_tmp8_ = log_stream;
			g_output_stream_printf ((GOutputStream*) _tmp8_, &_tmp9_, NULL, &_inner_error0_, "Founded errors - %d\n", join_0_count);
			bwritten = _tmp9_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (log_stream);
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
			_tmp10_ = log_stream;
			_tmp11_ = self->dir_compare_int_result;
			g_output_stream_printf ((GOutputStream*) _tmp10_, &_tmp12_, NULL, &_inner_error0_, "Files count - %d\n", g_list_length (_tmp11_));
			bwritten = _tmp12_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (log_stream);
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
			_tmp13_ = self->dir_compare_int_result;
			{
				GList* item_collection = NULL;
				GList* item_it = NULL;
				item_collection = _tmp13_;
				for (item_it = item_collection; item_it != NULL; item_it = item_it->next) {
					gint item = 0;
					item = (gint) ((gintptr) item_it->data);
					{
						GFileOutputStream* _tmp14_;
						GList* _tmp15_;
						gconstpointer _tmp16_;
						gsize _tmp17_ = 0UL;
						gint _tmp18_;
						_tmp14_ = log_stream;
						_tmp15_ = self->dir1_files_list;
						_tmp16_ = g_list_nth_data (_tmp15_, (guint) index);
						g_output_stream_printf ((GOutputStream*) _tmp14_, &_tmp17_, NULL, &_inner_error0_, "%d  -  %s\n", item, (const gchar*) _tmp16_);
						bwritten = _tmp17_;
						if (G_UNLIKELY (_inner_error0_ != NULL)) {
							_g_object_unref0 (log_stream);
							_g_object_unref0 (file);
							goto __catch0_g_error;
						}
						_tmp18_ = index;
						index = _tmp18_ + 1;
					}
				}
			}
			_tmp19_ = log_stream;
			g_output_stream_close ((GOutputStream*) _tmp19_, NULL, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_object_unref0 (log_stream);
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
		} else {
			g_print ("Error while generating log, can't open log\n");
		}
		_g_object_unref0 (log_stream);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp20_;
		const gchar* _tmp21_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp20_ = e;
		_tmp21_ = _tmp20_->message;
		g_print ("Error while generating log: %s\n", _tmp21_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return;
	}
}

static void
file_integrity_checker_file_comparator_class_init (FileIntegrityCheckerFileComparatorClass * klass,
                                                   gpointer klass_data)
{
	file_integrity_checker_file_comparator_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = file_integrity_checker_file_comparator_finalize;
}

static void
file_integrity_checker_file_comparator_instance_init (FileIntegrityCheckerFileComparator * self,
                                                      gpointer klass)
{
	self->dir1_files_list = NULL;
	self->dir2_files_list = NULL;
	self->dir_compare_int_result = NULL;
}

static void
file_integrity_checker_file_comparator_finalize (GObject * obj)
{
	FileIntegrityCheckerFileComparator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILE_INTEGRITY_CHECKER_TYPE_FILE_COMPARATOR, FileIntegrityCheckerFileComparator);
	_g_free0 (self->directory1);
	_g_free0 (self->directory2);
	(self->dir1_files_list == NULL) ? NULL : (self->dir1_files_list = (_g_list_free__g_free0_ (self->dir1_files_list), NULL));
	(self->dir2_files_list == NULL) ? NULL : (self->dir2_files_list = (_g_list_free__g_free0_ (self->dir2_files_list), NULL));
	(self->dir_compare_int_result == NULL) ? NULL : (self->dir_compare_int_result = (g_list_free (self->dir_compare_int_result), NULL));
	G_OBJECT_CLASS (file_integrity_checker_file_comparator_parent_class)->finalize (obj);
}

static GType
file_integrity_checker_file_comparator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FileIntegrityCheckerFileComparatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) file_integrity_checker_file_comparator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FileIntegrityCheckerFileComparator), 0, (GInstanceInitFunc) file_integrity_checker_file_comparator_instance_init, NULL };
	GType file_integrity_checker_file_comparator_type_id;
	file_integrity_checker_file_comparator_type_id = g_type_register_static (G_TYPE_OBJECT, "FileIntegrityCheckerFileComparator", &g_define_type_info, 0);
	return file_integrity_checker_file_comparator_type_id;
}

GType
file_integrity_checker_file_comparator_get_type (void)
{
	static volatile gsize file_integrity_checker_file_comparator_type_id__once = 0;
	if (g_once_init_enter (&file_integrity_checker_file_comparator_type_id__once)) {
		GType file_integrity_checker_file_comparator_type_id;
		file_integrity_checker_file_comparator_type_id = file_integrity_checker_file_comparator_get_type_once ();
		g_once_init_leave (&file_integrity_checker_file_comparator_type_id__once, file_integrity_checker_file_comparator_type_id);
	}
	return file_integrity_checker_file_comparator_type_id__once;
}

gchar*
file_integrity_checker_file_utils_calculate_checksum (const gchar* file_path)
{
	GChecksum* checksum = NULL;
	GChecksum* _tmp0_;
	gchar* md5_sum = NULL;
	GChecksum* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	GError* _inner_error0_ = NULL;
	gchar* result;
	g_return_val_if_fail (file_path != NULL, NULL);
	_tmp0_ = g_checksum_new (G_CHECKSUM_MD5);
	checksum = _tmp0_;
	{
		FILE* stream = NULL;
		FILE* _tmp1_;
		FILE* _tmp2_;
		_tmp1_ = g_fopen (file_path, "rb");
		stream = _tmp1_;
		_tmp2_ = stream;
		if (_tmp2_ != NULL) {
			guint8* buffer = NULL;
			guint8* _tmp3_;
			gint buffer_length1;
			gint _buffer_size_;
			gsize bytes_read = 0UL;
			_tmp3_ = g_new0 (guint8, 4096);
			buffer = _tmp3_;
			buffer_length1 = 4096;
			_buffer_size_ = buffer_length1;
			while (TRUE) {
				FILE* _tmp4_;
				guint8* _tmp5_;
				gint _tmp5__length1;
				GChecksum* _tmp6_;
				guint8* _tmp7_;
				gint _tmp7__length1;
				_tmp4_ = stream;
				_tmp5_ = buffer;
				_tmp5__length1 = buffer_length1;
				bytes_read = fread (_tmp5_, (gsize) 1, (gint) _tmp5__length1, _tmp4_);
				if (!(bytes_read > ((gsize) 0))) {
					break;
				}
				_tmp6_ = checksum;
				_tmp7_ = buffer;
				_tmp7__length1 = buffer_length1;
				g_checksum_update (_tmp6_, _tmp7_, (gsize) bytes_read);
			}
			buffer = (g_free (buffer), NULL);
		}
		_fclose0 (stream);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp8_;
		const gchar* _tmp9_;
		gchar* _tmp10_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp8_ = e;
		_tmp9_ = _tmp8_->message;
		g_print ("Error while calculating checksum: %s\n", _tmp9_);
		_tmp10_ = g_strdup ("Error");
		result = _tmp10_;
		_g_error_free0 (e);
		_g_free0 (md5_sum);
		_g_checksum_free0 (checksum);
		return result;
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_free0 (md5_sum);
		_g_checksum_free0 (checksum);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	_tmp11_ = checksum;
	_tmp12_ = g_checksum_get_string (_tmp11_);
	_tmp13_ = g_strdup (_tmp12_);
	_g_free0 (md5_sum);
	md5_sum = _tmp13_;
	result = md5_sum;
	_g_checksum_free0 (checksum);
	return result;
}

static const gchar*
string_to_string (const gchar* self)
{
	const gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}

gchar*
file_integrity_checker_file_utils_compare_files_lines (FileIntegrityCheckerFileUtils* self,
                                                       const gchar* file1_path,
                                                       const gchar* file2_path)
{
	GString* _result_ = NULL;
	GString* _tmp0_;
	GString* _tmp44_;
	const gchar* _tmp45_;
	gchar* _tmp46_;
	GError* _inner_error0_ = NULL;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (file1_path != NULL, NULL);
	g_return_val_if_fail (file2_path != NULL, NULL);
	_tmp0_ = g_string_new ("");
	_result_ = _tmp0_;
	{
		GFile* file1 = NULL;
		GFile* _tmp1_;
		GFile* file2 = NULL;
		GFile* _tmp2_;
		GFileInputStream* _tmp3_ = NULL;
		GFile* _tmp4_;
		GFileInputStream* _tmp5_;
		GDataInputStream* file1_stream = NULL;
		GDataInputStream* _tmp6_;
		GFileInputStream* _tmp7_ = NULL;
		GFile* _tmp8_;
		GFileInputStream* _tmp9_;
		GDataInputStream* file2_stream = NULL;
		GDataInputStream* _tmp10_;
		gchar* line1 = NULL;
		gchar* line2 = NULL;
		gint line_number = 0;
		_tmp1_ = g_file_new_for_path (file1_path);
		file1 = _tmp1_;
		_tmp2_ = g_file_new_for_path (file2_path);
		file2 = _tmp2_;
		_tmp4_ = file1;
		_tmp5_ = g_file_read (_tmp4_, NULL, &_inner_error0_);
		_tmp3_ = _tmp5_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (file2);
			_g_object_unref0 (file1);
			goto __catch0_g_error;
		}
		_tmp6_ = g_data_input_stream_new ((GInputStream*) _tmp3_);
		file1_stream = _tmp6_;
		_tmp8_ = file2;
		_tmp9_ = g_file_read (_tmp8_, NULL, &_inner_error0_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (file1_stream);
			_g_object_unref0 (_tmp3_);
			_g_object_unref0 (file2);
			_g_object_unref0 (file1);
			goto __catch0_g_error;
		}
		_tmp10_ = g_data_input_stream_new ((GInputStream*) _tmp7_);
		file2_stream = _tmp10_;
		line1 = NULL;
		line2 = NULL;
		line_number = 1;
		while (TRUE) {
			gboolean _tmp11_ = FALSE;
			gchar* _tmp12_ = NULL;
			GDataInputStream* _tmp13_;
			gchar* _tmp14_;
			gchar* _tmp15_;
			const gchar* _tmp16_;
			const gchar* _tmp22_;
			const gchar* _tmp24_;
			GString* _tmp26_;
			const gchar* _tmp27_;
			const gchar* _tmp28_;
			const gchar* _tmp29_;
			gint _tmp37_;
			_tmp13_ = file1_stream;
			_tmp14_ = g_data_input_stream_read_line (_tmp13_, NULL, NULL, &_inner_error0_);
			_tmp12_ = _tmp14_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_free0 (line2);
				_g_free0 (line1);
				_g_object_unref0 (file2_stream);
				_g_object_unref0 (_tmp7_);
				_g_object_unref0 (file1_stream);
				_g_object_unref0 (_tmp3_);
				_g_object_unref0 (file2);
				_g_object_unref0 (file1);
				goto __catch0_g_error;
			}
			_tmp15_ = _tmp12_;
			_tmp12_ = NULL;
			_g_free0 (line1);
			line1 = _tmp15_;
			_tmp16_ = line1;
			if (_tmp16_ != NULL) {
				_tmp11_ = TRUE;
			} else {
				gchar* _tmp17_ = NULL;
				GDataInputStream* _tmp18_;
				gchar* _tmp19_;
				gchar* _tmp20_;
				const gchar* _tmp21_;
				_tmp18_ = file2_stream;
				_tmp19_ = g_data_input_stream_read_line (_tmp18_, NULL, NULL, &_inner_error0_);
				_tmp17_ = _tmp19_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					_g_free0 (_tmp12_);
					_g_free0 (line2);
					_g_free0 (line1);
					_g_object_unref0 (file2_stream);
					_g_object_unref0 (_tmp7_);
					_g_object_unref0 (file1_stream);
					_g_object_unref0 (_tmp3_);
					_g_object_unref0 (file2);
					_g_object_unref0 (file1);
					goto __catch0_g_error;
				}
				_tmp20_ = _tmp17_;
				_tmp17_ = NULL;
				_g_free0 (line2);
				line2 = _tmp20_;
				_tmp21_ = line2;
				_tmp11_ = _tmp21_ != NULL;
				_g_free0 (_tmp17_);
			}
			if (!_tmp11_) {
				_g_free0 (_tmp12_);
				break;
			}
			_tmp22_ = line1;
			if (_tmp22_ == NULL) {
				gchar* _tmp23_;
				_tmp23_ = g_strdup ("");
				_g_free0 (line1);
				line1 = _tmp23_;
			}
			_tmp24_ = line2;
			if (_tmp24_ == NULL) {
				gchar* _tmp25_;
				_tmp25_ = g_strdup ("");
				_g_free0 (line2);
				line2 = _tmp25_;
			}
			_tmp26_ = _result_;
			_tmp27_ = line2;
			g_string_append (_tmp26_, _tmp27_);
			_tmp28_ = line1;
			_tmp29_ = line2;
			if (g_strcmp0 (_tmp28_, _tmp29_) != 0) {
				gchar* exclamation_marks = NULL;
				gchar* _tmp30_;
				GString* _tmp31_;
				const gchar* _tmp32_;
				const gchar* _tmp33_;
				gchar* _tmp34_;
				gchar* _tmp35_;
				GString* _tmp36_;
				_tmp30_ = g_strnfill ((gsize) 3, '!');
				exclamation_marks = _tmp30_;
				_tmp31_ = _result_;
				_tmp32_ = exclamation_marks;
				_tmp33_ = string_to_string (_tmp32_);
				_tmp34_ = g_strconcat (_tmp33_, "\n", NULL);
				_tmp35_ = _tmp34_;
				g_string_append (_tmp31_, _tmp35_);
				_g_free0 (_tmp35_);
				_tmp36_ = _result_;
				g_string_append (_tmp36_, "String before !!! is different");
				self->error_lines = g_list_append (self->error_lines, (gpointer) ((gintptr) line_number));
				_g_free0 (exclamation_marks);
			}
			_tmp37_ = line_number;
			line_number = _tmp37_ + 1;
			_g_free0 (_tmp12_);
		}
		_g_free0 (line2);
		_g_free0 (line1);
		_g_object_unref0 (file2_stream);
		_g_object_unref0 (_tmp7_);
		_g_object_unref0 (file1_stream);
		_g_object_unref0 (_tmp3_);
		_g_object_unref0 (file2);
		_g_object_unref0 (file1);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GString* _tmp38_;
		GError* _tmp39_;
		const gchar* _tmp40_;
		const gchar* _tmp41_;
		gchar* _tmp42_;
		gchar* _tmp43_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp38_ = _result_;
		_tmp39_ = e;
		_tmp40_ = _tmp39_->message;
		_tmp41_ = string_to_string (_tmp40_);
		_tmp42_ = g_strconcat ("File read error zzz: ", _tmp41_, "\n", NULL);
		_tmp43_ = _tmp42_;
		g_string_append (_tmp38_, _tmp43_);
		_g_free0 (_tmp43_);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_string_free0 (_result_);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	_tmp44_ = _result_;
	_tmp45_ = _tmp44_->str;
	_tmp46_ = g_strdup (_tmp45_);
	result = _tmp46_;
	_g_string_free0 (_result_);
	return result;
}

FileIntegrityCheckerFileUtils*
file_integrity_checker_file_utils_construct (GType object_type)
{
	FileIntegrityCheckerFileUtils * self = NULL;
	self = (FileIntegrityCheckerFileUtils*) g_object_new (object_type, NULL);
	return self;
}

FileIntegrityCheckerFileUtils*
file_integrity_checker_file_utils_new (void)
{
	return file_integrity_checker_file_utils_construct (FILE_INTEGRITY_CHECKER_TYPE_FILE_UTILS);
}

static void
file_integrity_checker_file_utils_class_init (FileIntegrityCheckerFileUtilsClass * klass,
                                              gpointer klass_data)
{
	file_integrity_checker_file_utils_parent_class = g_type_class_peek_parent (klass);
	G_OBJECT_CLASS (klass)->finalize = file_integrity_checker_file_utils_finalize;
}

static void
file_integrity_checker_file_utils_instance_init (FileIntegrityCheckerFileUtils * self,
                                                 gpointer klass)
{
	self->error_lines = NULL;
}

static void
file_integrity_checker_file_utils_finalize (GObject * obj)
{
	FileIntegrityCheckerFileUtils * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, FILE_INTEGRITY_CHECKER_TYPE_FILE_UTILS, FileIntegrityCheckerFileUtils);
	(self->error_lines == NULL) ? NULL : (self->error_lines = (g_list_free (self->error_lines), NULL));
	G_OBJECT_CLASS (file_integrity_checker_file_utils_parent_class)->finalize (obj);
}

static GType
file_integrity_checker_file_utils_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (FileIntegrityCheckerFileUtilsClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) file_integrity_checker_file_utils_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (FileIntegrityCheckerFileUtils), 0, (GInstanceInitFunc) file_integrity_checker_file_utils_instance_init, NULL };
	GType file_integrity_checker_file_utils_type_id;
	file_integrity_checker_file_utils_type_id = g_type_register_static (G_TYPE_OBJECT, "FileIntegrityCheckerFileUtils", &g_define_type_info, 0);
	return file_integrity_checker_file_utils_type_id;
}

GType
file_integrity_checker_file_utils_get_type (void)
{
	static volatile gsize file_integrity_checker_file_utils_type_id__once = 0;
	if (g_once_init_enter (&file_integrity_checker_file_utils_type_id__once)) {
		GType file_integrity_checker_file_utils_type_id;
		file_integrity_checker_file_utils_type_id = file_integrity_checker_file_utils_get_type_once ();
		g_once_init_leave (&file_integrity_checker_file_utils_type_id__once, file_integrity_checker_file_utils_type_id);
	}
	return file_integrity_checker_file_utils_type_id__once;
}

